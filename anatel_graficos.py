# -*- coding: utf-8 -*-
"""Anatel_Graficos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wbh11fqh8KHHZJxu4pdOA24nR_hPiM-M

<img loading="lazy" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/python/python-original.svg" width="40" height="40"/> <img src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/pandas/pandas-original-wordmark.svg" width="40" height="40"/>   <img loading="lazy" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/plotly/plotly-original-wordmark.svg" width="40" height="40"/>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/streamlit/streamlit-original-wordmark.svg" width="40" height="40"/>

---
>
**Dev**: Gabriel Prata
>
**Data**: 01/04/2024
>
**√öltima modifica√ß√£o**: 07/04/2024
>
---

![Badge em Desenvolvimento](http://img.shields.io/static/v1?label=STATUS&message=EM%20DESENVOLVIMENTO&color=GREEN&style=for-the-badge)

#**<font color=#85d338 size="6"> 1. Import libraries**
"""

# Importa√ß√£o de pacotes
import pandas as pd
import numpy as np
import missingno as ms # para tratamento de missings

#bibliotecas para visualiza√ß√£o de dados
import seaborn as sns
import plotly.express as px
import matplotlib.pyplot as plt

# Configura√ß√£o para n√£o exibir os warnings
import warnings
warnings.filterwarnings("ignore")

"""#**<font color=#85d338 size="6"> 2. Carga dos dados**

Carga do arquivo pre-processado gerado no notebook:
>
[<img loading="lazy" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/github/github-original-wordmark.svg" width="40" height="40"/>](https://github.com/gabrielmprata/anatel/blob/main/Anatel_PreProcessamento.ipynb)
[<img src="https://img.shields.io/badge/Colab-F9AB00?style=for-the-badge&logo=googlecolab&color=525252"/>](https://github.com/gabrielmprata/anatel/blob/main/Anatel_PreProcessamento.ipynb)
"""

# importando dataset de 2023

# URL de importa√ß√£o
url  = "https://raw.githubusercontent.com/gabrielmprata/anatel/main/datasets/banda_larga_fixa_2023.zip"

acesso_bl_2023 = pd.read_csv(url, compression='zip')

acesso_bl_2023.head()

"""###**<font color=#85d338> 2.1 Agrupado por colunas**"""

# importando dados de uma url para um dataframe

# URL de importa√ß√£o
url  = "https://raw.githubusercontent.com/gabrielmprata/anatel/main/datasets/banda_larga_fixa_2023_colunas.zip"

acesso_bl_2023_col = pd.read_csv(url, compression='zip')

acesso_bl_2023_col.head()

"""#**<font color=#85d338 size="6"> 3. Constru√ß√£o dos gr√°ficos üìä**

###**<font color=#85d338> 3.1 Mapa do Brasil**
"""

# Dataframe agrupando por Uf
df_total_uf = acesso_bl_2023.groupby(["ano","mes","UF"])['Acessos'].sum().reset_index()

#Carga do Json com as limita√ß√µes dos estados brasileiros

from urllib.request import urlopen
import json
with urlopen('https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson') as response:
    Brasil = json.load(response)

# definindo a informa√ß√£o do gr√°fico
state_id_map = {}
for feature in  Brasil["features"]:
    feature["id"] = feature["properties"]["sigla"]
    state_id_map[feature["properties"]["sigla"]] = feature["id"]

df_mapa = df_total_uf[(df_total_uf['mes'] == 12) & (df_total_uf['ano'] == 2023)].groupby(["UF"])['Acessos'].sum().reset_index()

#Plotando o mapa
fig = px.choropleth_mapbox(
 df_mapa, #database
 locations = 'UF', #define os limites no mapa
 geojson = Brasil, #Coordenadas geograficas dos estados
 color = "Acessos", #define a metrica para a cor da escala
 hover_name = 'UF', #informa√ß√£o no box do mapa
 hover_data =["UF"],
 #title = "Acessos", #titulo do mapa
 mapbox_style = "white-bg", #define o style do mapa
 center={"lat":-14, "lon": -55},#define os limites para plotar
 zoom = 2.5, #zoom inicial no mapa
 color_continuous_scale="greens", #cor dos estados
 #template='plotly_dark',
 opacity = 0.5 #opacidade da cor do mapa, para aparecer o fundo

)
fig.update_layout(
        plot_bgcolor='rgba(0, 0, 0, 0)',
        coloraxis_showscale=False, #Tira a legenda
        margin=dict(l=0, r=0, t=0, b=0),
        height=350
)

fig.show()

"""###**<font color=#85d338> 3.2 Heatmap**

<font color=#blue> A carga do gr√°fico ficou lenta no Streamlit, por isso n√£o usarei mais.
"""

# Ordenar o dataframe por UF para ordenar o eixo X
acesso_bl_2023.sort_values(by='UF', ascending=True,inplace=True)

fig0 = px.density_heatmap(acesso_bl_2023,
                         x="UF",
                         y="mes",
                         z="Acessos",
                         histfunc="sum",
                         labels=dict(mes="M√™s"),
                         color_continuous_scale="greens"
                         )

fig0.update_layout(yaxis = dict(
                                tickmode = 'array', # alterando o modo dos ticks
                                tickvals = acesso_bl_2023['mes'], # setando a posi√ß√£o do tick de x
                                ticktext = acesso_bl_2023['mes']),# setando o valor do tick de x
                                title="",
                                xaxis_title="",
                                yaxis_title="M√™s",
                                coloraxis_showscale=False, # tira a legenda
                                title_x = 0.5) #centralizando o titulo

fig0.update_traces(hovertemplate='UF: %{x}<br>' +
                                 'M√™s: %{y}<br>' +
                                 'Acessos: %{z}<br>'
                   )

fig0.show()

"""<font color=#85d338> **Pivot Table**

Uma alternativa, pois o heatmap demora muito a carregar no streamlit
"""

df_total_uf['AcessosMM'] = (df_total_uf['Acessos'] /1000000).round(2)

pv_faixa = pd.pivot_table(df_total_uf, index=['mes'], aggfunc='sum', columns=['UF'], values=['AcessosMM'],fill_value=0)

pv_faixa = pv_faixa.sort_values(by=['mes'], ascending=False)

pv_faixa.style.background_gradient(cmap='Greens').format("{:,}")

#Comando para pivot no Streamlit
 st.dataframe(pv_faixa.style.background_gradient(cmap='Greens').format("{:,}"),
                 height=500,
                 use_container_width=True,
                 width=1000)

"""###**<font color=#85d338> 3.3 Pie Chart por Meio de acesso**"""

# Dataframe agrupando por Meio acesso
df_meio_acesso = acesso_bl_2023.groupby(["mes","meio_acesso"])['Acessos'].sum().reset_index()

# Dataframe como o m√™s atual
df_meio_acesso_pie = df_meio_acesso[(df_meio_acesso['mes'] == 12)]

fig = px.pie(df_meio_acesso_pie,
             values='Acessos',
             names='meio_acesso',
             labels=dict(meio_acesso="Meio de acesso"),
             height=350, #altura
             width=350,  #largura
             color_discrete_sequence=px.colors.sequential.Greens_r
             )
fig.update_layout(showlegend=False)
fig.update_traces(textposition='outside',
                  textinfo='percent+label')
fig.show()

"""###**<font color=#85d338> 3.4 Line Chart evolu√ß√£o Meio de acesso**"""

fig = px.line(df_meio_acesso, x='mes', y='Acessos',
              color='meio_acesso',
              markers=True,
              height=500, width=800, #altura x largura
              labels=dict(meio_acesso="Meio de acesso", mes="M√™s"),
              color_discrete_sequence=px.colors.sequential.Greens_r,
              line_shape="spline",
              template="plotly_white"
              )
fig.update_layout(xaxis = dict(linecolor='rgba(0,0,0,1)', # adicionando linha em y = 0
                                tickmode = 'array', # alterando o modo dos ticks
                                tickvals = df_meio_acesso['mes'], # setando a posi√ß√£o do tick de x
                                ticktext = df_meio_acesso['mes']),# setando o valor do tick de x
                                title_x = 0.5) #centralizando o titulo

fig.update_xaxes(showspikes=True, spikecolor="black", spikesnap="cursor", spikemode="across")
fig.update_yaxes(showspikes=True, spikecolor="blue", spikethickness=2)
fig.update_layout(spikedistance=1000, hoverdistance=100)


fig.show()

"""###**<font color=#85d338> 3.5 Empresas com mais acesso em Banda Larga Fixa**"""

#Dataframe agrupado por empresa
mktshare = (acesso_bl_2023[['empresa', 'Acessos']]
            [(acesso_bl_2023['mes'] == 12)]
            ).groupby(['empresa'])['Acessos'].sum().reset_index()

mktshare_tot = sum(mktshare.Acessos) #Total de acessos

mktshare['market_share'] = ((mktshare['Acessos']/mktshare_tot)*100).round(2)
mktshare['ranking'] = (mktshare["Acessos"].rank(ascending = False)).astype(int)
gr_mktshare = mktshare.sort_values(by='market_share', ascending=False).head(10)

gr_mktshare

""">**<font color=#85d338>   Hist√≥rico por Empresas**

Nosso objetivo aqui √© criar uma coluna no dataframe com a s√©rie hist√≥rica dos acessos de cada empresa.
>
Dessa maneira, poderemos usar um elemento do Streamlit, para criar um mini gr√°fico (LineChartColumn) no grid de um dataframe.
"""

acesso_hist = acesso_bl_2023_col.groupby(['empresa']).sum(['2023-01','2023-02','2023-03','2023-04','2023-05','2023-06','2023-07','2023-08','2023-09','2023-10','2023-11','2023-12']).reset_index()

#Criando a coluna historica no formato que o Streamlit determina para o mini grafico

acesso_hist["historico"] = "[" + acesso_hist["2023-01"].apply(str) + ", " + acesso_hist["2023-02"].apply(str) + ", " + acesso_hist["2023-03"].apply(str) + ", " + acesso_hist["2023-04"].apply(str)+ ", " + acesso_hist["2023-05"].apply(str) + ", " + acesso_hist["2023-06"].apply(str) + ", " + acesso_hist["2023-07"].apply(str) + ", " + acesso_hist["2023-08"].apply(str) + ", " + acesso_hist["2023-09"].apply(str) + ", " + acesso_hist["2023-10"].apply(str) + ", " + acesso_hist["2023-11"].apply(str) + ", " + acesso_hist["2023-12"].apply(str) + "]"

mkt_share_tot = sum(acesso_hist["2023-12"])

acesso_hist['market_share'] = ((acesso_hist['2023-12']/mkt_share_tot)*100).round(2)
acesso_hist['ranking'] = (acesso_hist["2023-12"].rank(ascending = False)).astype(int)
gr_mktshare = acesso_hist.sort_values(by='ranking', ascending=True).head(10)
gr_mktshare

"""###**<font color=#85d338> 3.6 Evolu√ß√£o dos acessos por Porte da Prestadora**"""

#Dataframe agrupado por porte
df_porte = acesso_bl_2023.groupby(["mes","porte_prestadora"])['Acessos'].sum().reset_index()

fig = px.line(df_porte, x='mes', y='Acessos',
              color='porte_prestadora',
              markers=True,
              height=500, width=800, #altura x largura
              labels=dict(porte_prestadora="Porte da Prestadora", mes="M√™s"),
              color_discrete_sequence=["#85d338", "green"],
              #color_discrete_sequence=px.colors.sequential.Greens,
              line_shape="spline",
              template="plotly_white"
              )
fig.update_layout(xaxis = dict(#linecolor='rgba(0,0,0,1)', # adicionando linha em y = 0
                                tickmode = 'array', # alterando o modo dos ticks
                                tickvals = df_porte['mes'], # setando a posi√ß√£o do tick de x
                                ticktext = df_porte['mes']),# setando o valor do tick de x
                                title_x = 0.5) #centralizando o titulo


fig.show()

"""###**<font color=#85d338> 3.7 Evolu√ß√£o dos acessos por ano m√™s e as adi√ß√µes**"""

hist_acesso = acesso_bl_2023.groupby(["ano","mes"])['Acessos'].sum().reset_index()

hist_acesso['Acessos'] = ((hist_acesso['Acessos'])/1000000).round(2)

hist_acesso['ano_mes'] = hist_acesso['ano'].map(str) + hist_acesso['mes'].map(str)

hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20231','202301')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20232','202302')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20233','202303')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20234','202304')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20235','202305')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20236','202306')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20237','202307')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20238','202308')
hist_acesso.ano_mes =  hist_acesso.ano_mes.replace('20239','202309')

hist_acesso['acesso_ant'] = hist_acesso.Acessos.shift(1)
hist_acesso['var_acesso'] = (((hist_acesso['Acessos']/hist_acesso['acesso_ant'])*100)-100).round(2)

hist_acesso

fig1 = px.bar(hist_acesso, x="ano_mes", y="Acessos",
             template="plotly_white",
             text_auto=True,
             height=300, #altura
             #width=800,  #largura
             color_discrete_sequence=px.colors.sequential.Greens,
             labels=dict(ano_mes=" Ano M√™s", Acessos = "Acessos (MM)"),
             title = " ")

fig1.update_yaxes(showticklabels=False)
fig1.update_yaxes(showgrid=False)

fig1.update_layout(margin=dict(l=5, r=5, t=15, b=0))
fig1.show()

fig2 = px.bar(hist_acesso, x="ano_mes", y="var_acesso",
             template="plotly_white",
             text_auto=True,
             height=300, #altura
             #width=1000,  #largura
             color_discrete_sequence=px.colors.sequential.Greens,
             labels=dict(mes="M√™s", var_acesso = "Acessos"),
             title = "Varia√ß√£o MxM(%)")
fig2.update_traces(textposition='outside')
fig2.update_yaxes(showticklabels=False)
fig2.update_yaxes(showgrid=False)
fig2.update_yaxes(visible=False, fixedrange=True)

fig2.update_xaxes(showgrid=False)
fig2.update_xaxes(visible=True, fixedrange=True)

fig2.show()

"""No Colab o gr√°fico 2 n√£o ficou alinhado, mas no Streamlit ficou."""